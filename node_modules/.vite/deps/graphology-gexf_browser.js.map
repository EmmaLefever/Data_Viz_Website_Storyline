{
  "version": 3,
  "sources": ["../../graphology-utils/is-graph-constructor.js", "../../graphology-utils/add-edge.js", "../../graphology-gexf/common/helpers.js", "../../graphology-gexf/common/parser.js", "../../graphology-gexf/browser/parser.js", "../../graphology-utils/infer-type.js", "../../xml-writer/lib/xml-writer.js", "../../xml-writer/index.js", "../../graphology-gexf/common/writer.js", "../../graphology-gexf/browser/index.js"],
  "sourcesContent": ["/**\n * Graphology isGraphConstructor\n * ==============================\n *\n * Very simple function aiming at ensuring the given variable is a\n * graphology constructor.\n */\n\n/**\n * Checking the value is a graphology constructor.\n *\n * @param  {any}     value - Target value.\n * @return {boolean}\n */\nmodule.exports = function isGraphConstructor(value) {\n  return (\n    value !== null &&\n    typeof value === 'function' &&\n    typeof value.prototype === 'object' &&\n    typeof value.prototype.addUndirectedEdgeWithKey === 'function' &&\n    typeof value.prototype.dropNode === 'function'\n  );\n};\n", "/**\n * Graphology Edge Adders\n * =======================\n *\n * Generic edge addition functions that can be used to avoid nasty repetitive\n * conditions.\n */\nexports.addEdge = function addEdge(\n  graph,\n  undirected,\n  key,\n  source,\n  target,\n  attributes\n) {\n  if (undirected) {\n    if (key === null || key === undefined)\n      return graph.addUndirectedEdge(source, target, attributes);\n    else return graph.addUndirectedEdgeWithKey(key, source, target, attributes);\n  } else {\n    if (key === null || key === undefined)\n      return graph.addDirectedEdge(source, target, attributes);\n    else return graph.addDirectedEdgeWithKey(key, source, target, attributes);\n  }\n};\n\nexports.copyEdge = function copyEdge(\n  graph,\n  undirected,\n  key,\n  source,\n  target,\n  attributes\n) {\n  attributes = Object.assign({}, attributes);\n\n  if (undirected) {\n    if (key === null || key === undefined)\n      return graph.addUndirectedEdge(source, target, attributes);\n    else return graph.addUndirectedEdgeWithKey(key, source, target, attributes);\n  } else {\n    if (key === null || key === undefined)\n      return graph.addDirectedEdge(source, target, attributes);\n    else return graph.addDirectedEdgeWithKey(key, source, target, attributes);\n  }\n};\n\nexports.mergeEdge = function mergeEdge(\n  graph,\n  undirected,\n  key,\n  source,\n  target,\n  attributes\n) {\n  if (undirected) {\n    if (key === null || key === undefined)\n      return graph.mergeUndirectedEdge(source, target, attributes);\n    else\n      return graph.mergeUndirectedEdgeWithKey(key, source, target, attributes);\n  } else {\n    if (key === null || key === undefined)\n      return graph.mergeDirectedEdge(source, target, attributes);\n    else return graph.mergeDirectedEdgeWithKey(key, source, target, attributes);\n  }\n};\n\nexports.updateEdge = function updateEdge(\n  graph,\n  undirected,\n  key,\n  source,\n  target,\n  updater\n) {\n  if (undirected) {\n    if (key === null || key === undefined)\n      return graph.updateUndirectedEdge(source, target, updater);\n    else return graph.updateUndirectedEdgeWithKey(key, source, target, updater);\n  } else {\n    if (key === null || key === undefined)\n      return graph.updateDirectedEdge(source, target, updater);\n    else return graph.updateDirectedEdgeWithKey(key, source, target, updater);\n  }\n};\n", "/**\n * Graphology Common GEXF Helpers\n * ===============================\n *\n * Miscellaneous helpers used by both instance of the code.\n */\n\nvar SPACE_PATTERN = /^\\s$/;\nvar COMMA_SPLITTER = /\\s*,\\s*/;\nvar PIPE_SPLITTER = /\\s*\\|\\s*/;\n\nfunction isSpace(char) {\n  return SPACE_PATTERN.test(char);\n}\n\nfunction parseListPieces(string) {\n  var c, n, i, l;\n\n  var inPiece = false;\n  var escaping = false;\n  var piece = undefined;\n  var pieces = [];\n  var quoting = '';\n\n  for (i = 0, l = string.length; i < l; i++) {\n    c = string[i];\n\n    if (inPiece) {\n      if (piece === undefined) {\n        piece = '';\n      }\n\n      if (!quoting && c === ',') {\n        i--;\n        inPiece = false;\n        continue;\n      }\n\n      if (!escaping && c === quoting) {\n        inPiece = false;\n        continue;\n      }\n\n      if (c === '\\\\') {\n        if (i + 1 < l) {\n          n = string[i + 1];\n\n          if (n === 'r' || n === 't' || n === 'n' || n === '\\\\') {\n            if (n === 'n') {\n              piece += '\\n';\n            } else if (n === 't') {\n              piece += '\\t';\n            } else if (n === 'r') {\n              piece += '\\r';\n            } else {\n              piece += '\\\\';\n            }\n\n            escaping = false;\n            i++;\n            continue;\n          }\n        }\n\n        escaping = true;\n      } else {\n        piece += c;\n        escaping = false;\n      }\n    } else {\n      if (isSpace(c)) {\n        continue;\n      }\n\n      if (c === ',') {\n        if (piece !== undefined) {\n          pieces.push(piece);\n          piece = undefined;\n        }\n\n        continue;\n      }\n\n      if (c === '\"' || c === \"'\") {\n        quoting = c;\n      } else {\n        i--;\n        quoting = '';\n      }\n\n      inPiece = true;\n      escaping = false;\n    }\n  }\n\n  // Flushing last piece\n  if (piece !== undefined) {\n    pieces.push(piece);\n  }\n\n  return pieces;\n}\n\nfunction parseScalarValue(type, string) {\n  if (!type || type === 'string') {\n    return string;\n  }\n\n  if (type === 'boolean') {\n    return string === 'true';\n  }\n\n  // NOTE: long might cause issues at some point because\n  // JavaScript does not handle 64bit integers.\n  if (\n    type === 'byte' ||\n    type === 'short' ||\n    type === 'integer' ||\n    type === 'long' ||\n    type === 'float' ||\n    type === 'double'\n  ) {\n    return +string;\n  }\n\n  // NOTE: we fallback to raw string value\n  return string;\n}\n\nfunction parseValue(type, string) {\n  if (type.startsWith('list')) {\n    var subtype = type.slice(4);\n    var pieces;\n\n    if (\n      string.length >= 2 &&\n      string[0] === '[' &&\n      string[string.length - 1] === ']'\n    ) {\n      pieces = parseListPieces(string.slice(1, -1));\n    } else if (string.includes('|')) {\n      pieces = string.split(PIPE_SPLITTER);\n    } else if (string.includes(',')) {\n      pieces = string.split(COMMA_SPLITTER);\n    } else {\n      pieces = [string];\n    }\n\n    return pieces.map(function (piece) {\n      return parseScalarValue(subtype, piece);\n    });\n  } else {\n    return parseScalarValue(type, string);\n  }\n}\n\nexports.parseListPieces = parseListPieces;\nexports.parseScalarValue = parseScalarValue;\nexports.parseValue = parseValue;\n\n/**\n * Function deleting illegal characters from a potential tag name to avoid\n * generating invalid XML.\n *\n * @param  {string} type - Tag name.\n * @return {string}\n */\nvar SANITIZE_PATTERN = /[\"'<>&\\s]/g;\n\nexports.sanitizeTagName = function sanitizeTagName(tagName) {\n  return tagName.replace(SANITIZE_PATTERN, '').trim();\n};\n", "/* eslint no-self-compare: 0 */\n/**\n * Graphology Browser GEXF Parser\n * ===============================\n *\n * Browser version of the graphology GEXF parser using DOMParser to function.\n */\nvar isGraphConstructor = require('graphology-utils/is-graph-constructor');\nvar mergeEdge = require('graphology-utils/add-edge').mergeEdge;\nvar helpers = require('../common/helpers.js');\n\nvar parseValue = helpers.parseValue;\n\n/**\n * Function checking whether the given value is a NaN.\n *\n * @param  {any} value - Value to test.\n * @return {boolean}\n */\nfunction isReallyNaN(value) {\n  return value !== value;\n}\n\n/**\n * Function used to convert a viz:color attribute into a CSS rgba? or hex string.\n *\n * @param  {Node}   element - DOM element.\n * @return {string}\n */\nfunction getVizColor(element) {\n  var hex = element.getAttribute('hex');\n\n  if (hex) {\n    return hex;\n  }\n\n  var a = element.getAttribute('a');\n  var r = element.getAttribute('r');\n  var g = element.getAttribute('g');\n  var b = element.getAttribute('b');\n\n  return a\n    ? 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')'\n    : 'rgb(' + r + ',' + g + ',' + b + ')';\n}\n\n/**\n * Function returning the first matching tag of the `viz` namespace matching\n * the desired tag name.\n *\n * @param  {Node}   element - Target DOM element.\n * @param  {string} name    - Tag name.\n * @return {Node}\n */\nfunction getFirstMatchingVizTag(element, name) {\n  var vizElement = element.getElementsByTagName('viz:' + name)[0];\n\n  if (!vizElement) vizElement = element.getElementsByTagNameNS('viz', name)[0];\n\n  if (!vizElement) vizElement = element.getElementsByTagName(name)[0];\n\n  return vizElement;\n}\n\n/**\n * Function used to collect meta information.\n *\n * @param  {Array<Node>} elements - Target DOM element.\n * @return {object}\n */\nfunction collectMeta(elements) {\n  var meta = {};\n  var element;\n  var value;\n\n  for (var i = 0, l = elements.length; i < l; i++) {\n    element = elements[i];\n\n    if (element.nodeName === '#text') continue;\n\n    value = element.textContent.trim();\n\n    if (value) meta[element.tagName.toLowerCase()] = element.textContent;\n  }\n\n  return meta;\n}\n\n/**\n * Function used to extract the model from the right elements.\n *\n * @param  {Array<Node>} elements - Target DOM elements.\n * @return {array}                - The model & default attributes.\n */\nfunction extractModel(elements) {\n  var model = {};\n  var defaults = {};\n  var element;\n  var defaultElement;\n  var id;\n\n  for (var i = 0, l = elements.length; i < l; i++) {\n    element = elements[i];\n    id = element.getAttribute('id') || element.getAttribute('for');\n\n    model[id] = {\n      id: id,\n      type: element.getAttribute('type') || 'string',\n      title: !isReallyNaN(+id) ? element.getAttribute('title') || id : id\n    };\n\n    // Default?\n    defaultElement = element.getElementsByTagName('default')[0];\n\n    if (defaultElement)\n      defaults[model[id].title] = parseValue(\n        model[id].type,\n        defaultElement.textContent\n      );\n  }\n\n  return [model, defaults];\n}\n\n/**\n * Function used to collect an element's attributes.\n *\n * @param  {object}  model    - Data model to use.\n * @param  {object}  defaults - Default values.\n * @param  {Node}    element  - Target DOM element.\n * @param  {boolean} allowUndeclaredAttributes - Whether to allow undeclared attributes.\n * @return {object}           - The collected attributes.\n */\nfunction collectAttributes(\n  model,\n  defaults,\n  element,\n  allowUndeclaredAttributes\n) {\n  var data = {};\n  var label = element.getAttribute('label');\n  var weight = element.getAttribute('weight');\n  var kind = element.getAttribute('kind');\n\n  if (label) data.label = label;\n  if (weight) data.weight = +weight;\n  if (kind) data.kind = kind;\n\n  var valueElements = element.getElementsByTagName('attvalue');\n  var valueElement;\n  var attr;\n  var title;\n  var value;\n  var type;\n  var id;\n\n  for (var i = 0, l = valueElements.length; i < l; i++) {\n    valueElement = valueElements[i];\n    id = valueElement.getAttribute('id') || valueElement.getAttribute('for');\n    value = valueElement.getAttribute('value');\n    attr = model[id];\n\n    if (!attr) {\n      if (allowUndeclaredAttributes) {\n        title = id;\n        type = 'string';\n      } else {\n        throw new Error(\n          'graphology-gexf/parser: Found undeclared attribute \"' + id + '\"'\n        );\n      }\n    } else {\n      title = attr.title;\n      type = attr.type;\n    }\n\n    data[title] = parseValue(type, value);\n  }\n\n  // Applying default values\n  var k;\n\n  for (k in defaults) {\n    if (!(k in data)) data[k] = defaults[k];\n  }\n\n  // TODO: shortcut here to avoid viz when namespace is not set\n\n  // Attempting to find viz namespace tags\n\n  //-- 1) Color\n  var vizElement = getFirstMatchingVizTag(element, 'color');\n\n  if (vizElement) data.color = getVizColor(vizElement);\n\n  //-- 2) Size\n  vizElement = getFirstMatchingVizTag(element, 'size');\n\n  if (vizElement) data.size = +vizElement.getAttribute('value');\n\n  //-- 3) Position\n  var x, y, z;\n\n  vizElement = getFirstMatchingVizTag(element, 'position');\n\n  if (vizElement) {\n    x = vizElement.getAttribute('x');\n    y = vizElement.getAttribute('y');\n    z = vizElement.getAttribute('z');\n\n    if (x) data.x = +x;\n    if (y) data.y = +y;\n    if (z) data.z = +z;\n  }\n\n  //-- 4) Shape\n  vizElement = getFirstMatchingVizTag(element, 'shape');\n\n  if (vizElement) data.shape = vizElement.getAttribute('value');\n\n  //-- 5) Thickness\n  vizElement = getFirstMatchingVizTag(element, 'thickness');\n\n  if (vizElement) data.thickness = +vizElement.getAttribute('value');\n\n  return data;\n}\n\n/**\n * Factory taking implementations of `DOMParser` & `Document` returning\n * the parser function.\n */\nmodule.exports = function createParserFunction(DOMParser, Document) {\n  /**\n   * Function taking either a string or a document and returning a\n   * graphology instance.\n   *\n   * @param {function}        Graph  - A graphology constructor.\n   * @param {string|Document} source - The source to parse.\n   * @param {object}          options - Parsing options.\n   */\n\n  // TODO: option to map the data to the attributes for customization, nodeModel, edgeModel, nodeReducer, edgeReducer\n  // TODO: option to disable the model mapping heuristic\n  return function parse(Graph, source, options) {\n    options = options || {};\n\n    var addMissingNodes = options.addMissingNodes === true;\n    var allowUndeclaredAttributes = options.allowUndeclaredAttributes === true;\n    var respectInputGraphType = options.respectInputGraphType === true;\n    var mergeResult;\n\n    var xmlDoc = source;\n\n    var element, result, type, attributes, id, s, t, i, l;\n\n    if (!isGraphConstructor(Graph))\n      throw new Error('graphology-gexf/parser: invalid Graph constructor.');\n\n    // If source is a string, we are going to parse it\n    if (typeof source === 'string')\n      xmlDoc = new DOMParser().parseFromString(source, 'application/xml');\n\n    if (!(xmlDoc instanceof Document))\n      throw new Error(\n        'graphology-gexf/parser: source should either be a XML document or a string.'\n      );\n\n    // Finding useful elements\n    var GRAPH_ELEMENT = xmlDoc.getElementsByTagName('graph')[0];\n    var META_ELEMENT = xmlDoc.getElementsByTagName('meta')[0];\n    var META_ELEMENTS = (META_ELEMENT && META_ELEMENT.childNodes) || [];\n    var NODE_ELEMENTS = xmlDoc.getElementsByTagName('node');\n    var EDGE_ELEMENTS = xmlDoc.getElementsByTagName('edge');\n    var MODEL_ELEMENTS = xmlDoc.getElementsByTagName('attributes');\n    var NODE_MODEL_ELEMENTS = [];\n    var EDGE_MODEL_ELEMENTS = [];\n\n    for (i = 0, l = MODEL_ELEMENTS.length; i < l; i++) {\n      element = MODEL_ELEMENTS[i];\n\n      if (element.getAttribute('class') === 'node')\n        NODE_MODEL_ELEMENTS = element.getElementsByTagName('attribute');\n      else if (element.getAttribute('class') === 'edge')\n        EDGE_MODEL_ELEMENTS = element.getElementsByTagName('attribute');\n    }\n\n    // Information\n    var DEFAULT_EDGE_TYPE =\n      GRAPH_ELEMENT.getAttribute('defaultedgetype') || 'undirected';\n\n    if (DEFAULT_EDGE_TYPE === 'mutual') DEFAULT_EDGE_TYPE = 'undirected';\n\n    // Computing models\n    result = extractModel(NODE_MODEL_ELEMENTS);\n\n    var NODE_MODEL = result[0];\n    var NODE_DEFAULT_ATTRIBUTES = result[1];\n\n    result = extractModel(EDGE_MODEL_ELEMENTS);\n\n    var EDGE_MODEL = result[0];\n    var EDGE_DEFAULT_ATTRIBUTES = result[1];\n\n    // Polling the first edge to guess the type of the edges\n    var graphType = EDGE_ELEMENTS[0]\n      ? EDGE_ELEMENTS[0].getAttribute('type') || DEFAULT_EDGE_TYPE\n      : 'mixed';\n\n    // Instantiating our graph\n    var graphOptions = respectInputGraphType ? {} : {type: graphType};\n\n    var graph = new Graph(graphOptions);\n\n    // Collecting meta\n    var meta = collectMeta(META_ELEMENTS);\n    var lastModifiedDate =\n      META_ELEMENT && META_ELEMENT.getAttribute('lastmodifieddate');\n\n    graph.replaceAttributes(meta);\n\n    if (lastModifiedDate)\n      graph.setAttribute('lastModifiedDate', lastModifiedDate);\n\n    // Adding nodes\n    for (i = 0, l = NODE_ELEMENTS.length; i < l; i++) {\n      element = NODE_ELEMENTS[i];\n\n      graph.addNode(\n        element.getAttribute('id'),\n        collectAttributes(\n          NODE_MODEL,\n          NODE_DEFAULT_ATTRIBUTES,\n          element,\n          allowUndeclaredAttributes\n        )\n      );\n    }\n\n    // Adding edges\n    for (i = 0, l = EDGE_ELEMENTS.length; i < l; i++) {\n      element = EDGE_ELEMENTS[i];\n\n      id = element.getAttribute('id');\n      type = element.getAttribute('type') || DEFAULT_EDGE_TYPE;\n      s = element.getAttribute('source');\n      t = element.getAttribute('target');\n      attributes = collectAttributes(\n        EDGE_MODEL,\n        EDGE_DEFAULT_ATTRIBUTES,\n        element,\n        allowUndeclaredAttributes\n      );\n\n      // If we encountered an edge with a different type, we upgrade the graph\n      if (type !== graph.type && graph.type !== 'mixed') {\n        if (respectInputGraphType)\n          throw new Error(\n            \"graphology-gexf/parser: one of the file's edges does not respect the input graph type: \" +\n              graph.type +\n              '.'\n          );\n\n        graph = graph.copy({type: 'mixed'});\n      }\n\n      // If we encountered twice the same edge, we upgrade the graph\n      if (\n        !graph.multi &&\n        ((type === 'directed' && graph.hasDirectedEdge(s, t)) ||\n          graph.hasUndirectedEdge(s, t))\n      ) {\n        if (respectInputGraphType)\n          throw new Error(\n            'graphology-gexf/parser: the file contains parallel edges that the input graph type does not allow.'\n          );\n\n        graph = graph.copy({multi: true});\n      }\n\n      mergeResult = mergeEdge(\n        graph,\n        type !== 'directed',\n        id || null,\n        s,\n        t,\n        attributes\n      );\n\n      if (!addMissingNodes && (mergeResult[2] || mergeResult[3])) {\n        throw new Error(\n          'graphology-gexf/parser: one of your gexf file edges points to an inexisting node. Set the parser `addMissingNodes` option to `true` if you do not care.'\n        );\n      }\n    }\n\n    return graph;\n  };\n};\n", "/**\n * Graphology Browser GEXF Parser\n * ===============================\n *\n * Browser version of the graphology GEXF parser.\n */\nvar createParserFunction = require('../common/parser.js');\n\nmodule.exports = createParserFunction(DOMParser, Document);\n", "/**\n * Graphology inferType\n * =====================\n *\n * Useful function used to \"guess\" the real type of the given Graph using\n * introspection.\n */\nvar isGraph = require('./is-graph.js');\n\n/**\n * Returning the inferred type of the given graph.\n *\n * @param  {Graph}   graph - Target graph.\n * @return {boolean}\n */\nmodule.exports = function inferType(graph) {\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-utils/infer-type: expecting a valid graphology instance.'\n    );\n\n  var declaredType = graph.type;\n\n  if (declaredType !== 'mixed') return declaredType;\n\n  if (\n    (graph.directedSize === 0 && graph.undirectedSize === 0) ||\n    (graph.directedSize > 0 && graph.undirectedSize > 0)\n  )\n    return 'mixed';\n\n  if (graph.directedSize > 0) return 'directed';\n\n  return 'undirected';\n};\n", "\nfunction isFalse(s) {\n  return typeof s !== 'number' && !s;\n}\n\nfunction strval(s) {\n  if (typeof s == 'string') {\n    return s;\n  }\n  else if (typeof s == 'number') {\n    return s+'';\n  }\n  else if (typeof s == 'function') {\n    return s();\n  }\n  else if (s instanceof XMLWriter) {\n    return s.toString();\n  }\n  else throw Error('Bad Parameter');\n}\n\nfunction XMLWriter(indent, callback) {\n\n    if (!(this instanceof XMLWriter)) {\n        return new XMLWriter();\n    }\n\n    this.name_regex = /[_:A-Za-z][-._:A-Za-z0-9]*/;\n    this.indent = indent ? true : false;\n    this.indentString = this.indent && typeof indent === 'string' ? indent : '    ';\n    this.output = '';\n    this.stack = [];\n    this.tags = 0;\n    this.attributes = 0;\n    this.attribute = 0;\n    this.texts = 0;\n    this.comment = 0;\n    this.dtd = 0;\n    this.root = '';\n    this.pi = 0;\n    this.cdata = 0;\n    this.started_write = false;\n    this.writer;\n    this.writer_encoding = 'UTF-8';\n\n    if (typeof callback == 'function') {\n        this.writer = callback;\n    } else {\n        this.writer = function (s, e) {\n            this.output += s;\n        }\n    }\n}\n\nXMLWriter.prototype = {\n    toString : function () {\n        this.flush();\n        return this.output;\n    },\n\n    indenter : function () {\n      if (this.indent) {\n        this.write('\\n');\n        for (var i = 1; i < this.tags; i++) {\n          this.write(this.indentString);\n        }\n      }\n    },\n\n    write : function () {\n        for (var i = 0; i < arguments.length; i++) {\n            this.writer(arguments[i], this.writer_encoding);\n        }\n    },\n\n\n    flush : function () {\n        for (var i = this.tags; i > 0; i--) {\n            this.endElement();\n        }\n        this.tags = 0;\n    },\n\n    startDocument : function (version, encoding, standalone) {\n        if (this.tags || this.attributes) return this;\n\n        this.startPI('xml');\n        this.startAttribute('version');\n        this.text(typeof version == \"string\" ? version : \"1.0\");\n        this.endAttribute();\n        if (typeof encoding == \"string\") {\n            this.startAttribute('encoding');\n            this.text(encoding);\n            this.endAttribute();\n            this.writer_encoding = encoding;\n        }\n        if (standalone) {\n            this.startAttribute('standalone');\n            this.text(\"yes\");\n            this.endAttribute();\n        }\n        this.endPI();\n        if (!this.indent) {\n          this.write('\\n');\n        }\n        return this;\n    },\n\n    endDocument : function () {\n        if (this.attributes) this.endAttributes();\n        return this;\n    },\n\n    writeElement : function (name, content) {\n        return this.startElement(name).text(content).endElement();\n    },\n\n    writeElementNS : function (prefix, name, uri, content) {\n        if (!content) {\n            content = uri;\n        }\n        return this.startElementNS(prefix, name, uri).text(content).endElement();\n    },\n\n    startElement : function (name) {\n        name = strval(name);\n        if (!name.match(this.name_regex)) throw Error('Invalid Parameter');\n        if (this.tags === 0 && this.root && this.root !== name) throw Error('Invalid Parameter');\n        if (this.attributes) this.endAttributes();\n        ++this.tags;\n        this.texts = 0;\n        if (this.stack.length > 0)\n          this.stack[this.stack.length-1].containsTag = true;\n\n        this.stack.push({\n            name: name,\n            tags: this.tags\n        });\n        if (this.started_write) this.indenter();\n        this.write('<', name);\n        this.startAttributes();\n        this.started_write = true;\n        return this;\n    },\n    startElementNS : function (prefix, name, uri) {\n        prefix = strval(prefix);\n        name = strval(name);\n\n        if (!prefix.match(this.name_regex)) throw Error('Invalid Parameter');\n        if (!name.match(this.name_regex)) throw Error('Invalid Parameter');\n        if (this.attributes) this.endAttributes();\n        ++this.tags;\n        this.texts = 0;\n        if (this.stack.length > 0)\n          this.stack[this.stack.length-1].containsTag = true;\n\n        this.stack.push({\n            name: prefix + ':' + name,\n            tags: this.tags\n        });\n        if (this.started_write) this.indenter();\n        this.write('<', prefix + ':' + name);\n        this.startAttributes();\n        this.started_write = true;\n        return this;\n    },\n\n    endElement : function () {\n        if (!this.tags) return this;\n        var t = this.stack.pop();\n        if (this.attributes > 0) {\n            if (this.attribute) {\n                if (this.texts) this.endAttribute();\n                this.endAttribute();\n            }\n            this.write('/');\n            this.endAttributes();\n        } else {\n            if (t.containsTag) this.indenter();\n            this.write('</', t.name, '>');\n        }\n        --this.tags;\n        this.texts = 0;\n        return this;\n    },\n\n    writeAttribute : function (name, content) {\n        if (typeof content == 'function') {\n          content = content();\n        }\n        if (isFalse(content)) {\n           return this;\n        }\n        return this.startAttribute(name).text(content).endAttribute();\n    },\n    writeAttributeNS : function (prefix, name, uri, content) {\n        if (!content) {\n            content = uri;\n        }\n        if (typeof content == 'function') {\n          content = content();\n        }\n        if (isFalse(content)) {\n          return this;\n        }\n        return this.startAttributeNS(prefix, name, uri).text(content).endAttribute();\n    },\n\n    startAttributes : function () {\n        this.attributes = 1;\n        return this;\n    },\n\n    endAttributes : function () {\n        if (!this.attributes) return this;\n        if (this.attribute) this.endAttribute();\n        this.attributes = 0;\n        this.attribute = 0;\n        this.texts = 0;\n        this.write('>');\n        return this;\n    },\n\n    startAttribute : function (name) {\n        name = strval(name);\n        if (!name.match(this.name_regex)) throw Error('Invalid Parameter');\n        if (!this.attributes && !this.pi) return this;\n        if (this.attribute) return this;\n        this.attribute = 1;\n        this.write(' ', name, '=\"');\n        return this;\n    },\n    startAttributeNS : function (prefix, name, uri) {\n        prefix = strval(prefix);\n        name = strval(name);\n\n        if (!prefix.match(this.name_regex)) throw Error('Invalid Parameter');\n        if (!name.match(this.name_regex)) throw Error('Invalid Parameter');\n        if (!this.attributes && !this.pi) return this;\n        if (this.attribute) return this;\n        this.attribute = 1;\n        this.write(' ', prefix + ':' + name, '=\"');\n        return this;\n    },\n    endAttribute : function () {\n        if (!this.attribute) return this;\n        this.attribute = 0;\n        this.texts = 0;\n        this.write('\"');\n        return this;\n    },\n\n    text : function (content) {\n        content = strval(content);\n        if (!this.tags && !this.comment && !this.pi && !this.cdata) return this;\n        if (this.attributes && this.attribute) {\n            ++this.texts;\n            this.write(content\n                       .replace(/&/g, '&amp;')\n                       .replace(/</g, '&lt;')\n                       .replace(/\"/g, '&quot;')\n                       .replace(/\\t/g, '&#x9;')\n                       .replace(/\\n/g, '&#xA;')\n                       .replace(/\\r/g, '&#xD;')\n                      );\n            return this;\n        } else if (this.attributes && !this.attribute) {\n            this.endAttributes();\n        }\n        if (this.comment || this.cdata) {\n            this.write(content);\n        }\n        else {\n          this.write(content.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;'));\n        }\n        ++this.texts;\n        this.started_write = true;\n        return this;\n    },\n\n    writeComment : function (content) {\n        return this.startComment().text(content).endComment();\n    },\n\n    startComment : function () {\n        if (this.comment) return this;\n        if (this.attributes) this.endAttributes();\n        this.indenter();\n        this.write('<!--');\n        this.comment = 1;\n        this.started_write = true;\n        return this;\n    },\n\n    endComment : function () {\n        if (!this.comment) return this;\n        this.write('-->');\n        this.comment = 0;\n        return this;\n    },\n\n    writeDocType : function (name, pubid, sysid, subset) {\n        return this.startDocType(name, pubid, sysid, subset).endDocType()\n    },\n\n    startDocType : function (name, pubid, sysid, subset) {\n        if (this.dtd || this.tags) return this;\n\n        name = strval(name);\n        pubid = pubid ? strval(pubid) : pubid;\n        sysid = sysid ? strval(sysid) : sysid;\n        subset = subset ? strval(subset) : subset;\n\n        if (!name.match(this.name_regex)) throw Error('Invalid Parameter');\n        if (pubid && !pubid.match(/^[\\w\\-][\\w\\s\\-\\/\\+\\:\\.]*/)) throw Error('Invalid Parameter');\n        if (sysid && !sysid.match(/^[\\w\\.][\\w\\-\\/\\\\\\:\\.]*/)) throw Error('Invalid Parameter');\n        if (subset && !subset.match(/[\\w\\s\\<\\>\\+\\.\\!\\#\\-\\?\\*\\,\\(\\)\\|]*/)) throw Error('Invalid Parameter');\n\n        pubid = pubid ? ' PUBLIC \"' + pubid + '\"' : (sysid) ? ' SYSTEM' : '';\n        sysid = sysid ? ' \"' + sysid + '\"' : '';\n        subset = subset ? ' [' + subset + ']': '';\n\n        if (this.started_write) this.indenter();\n        this.write('<!DOCTYPE ', name, pubid, sysid, subset);\n        this.root = name;\n        this.dtd = 1;\n        this.started_write = true;\n        return this;\n    },\n\n    endDocType : function () {\n        if (!this.dtd) return this;\n        this.write('>');\n        return this;\n    },\n\n    writePI : function (name, content) {\n        return this.startPI(name).text(content).endPI()\n    },\n\n    startPI : function (name) {\n        name = strval(name);\n        if (!name.match(this.name_regex)) throw Error('Invalid Parameter');\n        if (this.pi) return this;\n        if (this.attributes) this.endAttributes();\n        if (this.started_write) this.indenter();\n        this.write('<?', name);\n        this.pi = 1;\n        this.started_write = true;\n        return this;\n    },\n\n    endPI : function () {\n        if (!this.pi) return this;\n        this.write('?>');\n        this.pi = 0;\n        return this;\n    },\n\n    writeCData : function (content) {\n        return this.startCData().text(content).endCData();\n    },\n\n    startCData : function () {\n        if (this.cdata) return this;\n        if (this.attributes) this.endAttributes();\n        this.indenter();\n        this.write('<![CDATA[');\n        this.cdata = 1;\n        this.started_write = true;\n        return this;\n    },\n\n    endCData : function () {\n        if (!this.cdata) return this;\n        this.write(']]>');\n        this.cdata = 0;\n        return this;\n    },\n\n    writeRaw : function(content) {\n        content = strval(content);\n        if (!this.tags && !this.comment && !this.pi && !this.cdata) return this;\n        if (this.attributes && this.attribute) {\n            ++this.texts;\n            this.write(content.replace('&', '&amp;').replace('\"', '&quot;'));\n            return this;\n        } else if (this.attributes && !this.attribute) {\n            this.endAttributes();\n        }\n        ++this.texts;\n        this.write(content);\n        this.started_write = true;\n        return this;\n    }\n\n}\n\nmodule.exports = XMLWriter;\n", "module.exports = require('./lib/xml-writer.js');\n", "/* eslint no-self-compare: 0 */\n/**\n * Graphology Common GEXF Writer\n * ==============================\n *\n * GEXF writer working for both node.js & the browser.\n */\nvar isGraph = require('graphology-utils/is-graph');\nvar inferType = require('graphology-utils/infer-type');\nvar XMLWriter = require('xml-writer');\nvar sanitizeTagName = require('./helpers.js').sanitizeTagName;\n\n/**\n * Constants.\n */\nvar VIZ_RESERVED_NAMES = new Set([\n  'color',\n  'size',\n  'x',\n  'y',\n  'z',\n  'shape',\n  'thickness'\n]);\n\nvar RGBA_TEST = /^\\s*rgba?\\s*\\(/i;\nvar RGBA_MATCH =\n  /^\\s*rgba?\\s*\\(\\s*([0-9]*)\\s*,\\s*([0-9]*)\\s*,\\s*([0-9]*)\\s*(?:,\\s*([.0-9]*))?\\)\\s*$/;\n\n/**\n * Function used to transform a CSS color into a RGBA object.\n *\n * @param  {string} value - Target value.\n * @return {object}\n */\nfunction CSSColorToRGBA(value) {\n  if (!value || typeof value !== 'string') return {};\n\n  if (value[0] === '#') {\n    value = value.slice(1);\n\n    return value.length === 3\n      ? {\n          r: parseInt(value[0] + value[0], 16),\n          g: parseInt(value[1] + value[1], 16),\n          b: parseInt(value[2] + value[2], 16)\n        }\n      : {\n          r: parseInt(value[0] + value[1], 16),\n          g: parseInt(value[2] + value[3], 16),\n          b: parseInt(value[4] + value[5], 16)\n        };\n  } else if (RGBA_TEST.test(value)) {\n    var result = {};\n\n    value = value.match(RGBA_MATCH);\n    result.r = +value[1];\n    result.g = +value[2];\n    result.b = +value[3];\n\n    if (value[4]) result.a = +value[4];\n\n    return result;\n  }\n\n  return {};\n}\n\n/**\n * Function used to map an element's attributes to a standardized map of\n * GEXF expected properties (label, viz, attributes).\n *\n * @param  {string} type       - The element's type.\n * @param  {string} key        - The element's key.\n * @param  {object} attributes - The element's attributes.\n * @return {object}\n */\nfunction DEFAULT_ELEMENT_FORMATTER(type, key, attributes) {\n  var output = {},\n    name;\n\n  for (name in attributes) {\n    if (name === 'label') {\n      output.label = attributes.label;\n    } else if (type === 'edge' && name === 'weight') {\n      output.weight = attributes.weight;\n    } else if (type === 'edge' && name === 'kind') {\n      output.kind = attributes.kind;\n    } else if (VIZ_RESERVED_NAMES.has(name)) {\n      output.viz = output.viz || {};\n      output.viz[name] = attributes[name];\n    } else {\n      output.attributes = output.attributes || {};\n      output.attributes[name] = attributes[name];\n    }\n  }\n\n  return output;\n}\n\nvar DEFAULT_NODE_FORMATTER = DEFAULT_ELEMENT_FORMATTER.bind(null, 'node');\nvar DEFAULT_EDGE_FORMATTER = DEFAULT_ELEMENT_FORMATTER.bind(null, 'edge');\n\n/**\n * Function used to check whether the given integer is 32 bits or not.\n *\n * @param  {number} number - Target number.\n * @return {boolean}\n */\nfunction is32BitInteger(number) {\n  return number <= 0x7fffffff && number >= -0x7fffffff;\n}\n\n/**\n * Function used to check whether the given value is \"empty\".\n *\n * @param  {any} value - Target value.\n * @return {boolean}\n */\nfunction isEmptyValue(value) {\n  return (\n    typeof value === 'undefined' ||\n    value === null ||\n    value === '' ||\n    value !== value\n  );\n}\n\nvar TYPE_PRIORITIES = {\n  liststring: 0,\n  listdouble: 1,\n  listlong: 2,\n  listinteger: 3,\n  listboolean: 4,\n  string: 5,\n  double: 6,\n  long: 7,\n  integer: 8,\n  boolean: 9,\n  empty: 10\n};\n\n/**\n * Function used to detect a JavaScript's value type in the GEXF model.\n *\n * @param  {any}    value - Target value.\n * @return {string}\n */\nfunction inferScalarValueType(value) {\n  if (isEmptyValue(value)) return 'empty';\n\n  if (typeof value === 'boolean') return 'boolean';\n\n  if (typeof value === 'object') return 'string';\n\n  // Numbers\n  if (typeof value === 'number') {\n    // Integer\n    if (value === (value | 0)) {\n      // Long (JavaScript integer can go up to 53 bit)?\n      return is32BitInteger(value) ? 'integer' : 'long';\n    }\n\n    // JavaScript numbers are 64 bit float, hence the double\n    return 'double';\n  }\n\n  return 'string';\n}\n\nfunction inferListValueType(values) {\n  var type = 'empty';\n  var priority = TYPE_PRIORITIES[type];\n  var value, t, p;\n\n  for (var i = 0, l = values.length; i < l; i++) {\n    value = values[i];\n    t = inferScalarValueType(value);\n    p = TYPE_PRIORITIES[t];\n\n    if (p < priority) {\n      type = t;\n      priority = p;\n    }\n  }\n\n  return type;\n}\n\nfunction inferValueType(value) {\n  // NOTE: at some point we might need a frame-independent test for this...\n  // NOTE: it would be nice not to have to reallocate the Set as an Array\n  // but good enough for the time being.\n  if (value instanceof Set) {\n    value = Array.from(value);\n  }\n\n  if (Array.isArray(value)) {\n    var type = inferListValueType(value);\n\n    if (type === 'empty') return 'empty';\n\n    return 'list' + type;\n  }\n\n  return inferScalarValueType(value);\n}\n\nvar TO_SANITIZE_PATTERN = /[\\r\\t\\n]/g;\n\nvar SINGLE_QUOTE = \"'\";\nvar DOUBLE_QUOTE = '\"';\n\nfunction serializeValue(type, value) {\n  if (type !== 'string' || TO_SANITIZE_PATTERN.test(value)) {\n    return JSON.stringify(value);\n  }\n\n  if (!value.includes(SINGLE_QUOTE)) {\n    if (!value.includes(DOUBLE_QUOTE)) {\n      return value;\n    }\n    return SINGLE_QUOTE + value + SINGLE_QUOTE;\n  }\n\n  return JSON.stringify(value);\n}\n\n/**\n * Function used to cast the given value into the given type.\n *\n * @param  {string} type  - Target type.\n * @param  {any}    value - Value to cast.\n * @return {string}\n */\nfunction cast(version, type, value) {\n  if (type.startsWith('list')) {\n    if (value instanceof Set) value = Array.from(value);\n    var arrayValue = Array.isArray(value) ? value : [value];\n\n    var subtype = type.slice(4);\n    if (version === '1.3') {\n      return (\n        '[' +\n        arrayValue\n          .map(function (v) {\n            return serializeValue(subtype, v);\n          })\n          .join(', ') +\n        ']'\n      );\n    } else {\n      return arrayValue.join('|');\n    }\n  }\n\n  return '' + value;\n}\n\n/**\n * Function used to collect data from a graph's nodes.\n *\n * @param  {Graph}    graph   - Target graph.\n * @param  {function} format  - Function formatting the nodes attributes.\n * @return {array}\n */\nfunction collectNodeData(graph, format) {\n  var nodes = new Array(graph.order);\n  var i = 0;\n\n  graph.forEachNode(function (node, attr) {\n    var data = format(node, attr);\n    data.key = node;\n    nodes[i++] = data;\n  });\n\n  return nodes;\n}\n\n/**\n * Function used to collect data from a graph's edges.\n *\n * @param  {Graph}    graph   - Target graph.\n * @param  {function} reducer - Function reducing the edges attributes.\n * @return {array}\n */\nfunction collectEdgeData(graph, reducer) {\n  var edges = new Array(graph.size);\n  var i = 0;\n\n  graph.forEachEdge(function (\n    edge,\n    attr,\n    source,\n    target,\n    _sa,\n    _ta,\n    undirected\n  ) {\n    var data = reducer(edge, attr);\n    data.key = edge;\n    data.source = source;\n    data.target = target;\n    data.undirected = undirected;\n    edges[i++] = data;\n  });\n\n  return edges;\n}\n\n/**\n * Function used to infer the model of the graph's nodes or edges.\n *\n * @param  {array} elements - The graph's relevant elements.\n * @return {array}\n */\n\n// TODO: on large graph, we could also sample or let the user indicate the types\nfunction inferModel(elements) {\n  var model = {};\n  var attributes;\n  var type, currentType;\n  var k;\n\n  // Testing every attributes\n  for (var i = 0, l = elements.length; i < l; i++) {\n    attributes = elements[i].attributes;\n\n    if (!attributes) continue;\n\n    for (k in attributes) {\n      type = inferValueType(attributes[k]);\n\n      if (type === 'empty') continue;\n\n      currentType = model[k];\n\n      if (!currentType) model[k] = type;\n      else {\n        if (\n          type !== currentType &&\n          TYPE_PRIORITIES[type] < TYPE_PRIORITIES[currentType]\n        ) {\n          model[k] = type;\n        }\n      }\n    }\n  }\n\n  // TODO: check default values\n  return model;\n}\n\n/**\n * Function used to write a model.\n *\n * @param {XMLWriter} writer     - The writer to use.\n * @param {object}    model      - Model to write.\n * @param {string}    modelClass - Class of the model.\n */\nfunction writeModel(writer, model, modelClass) {\n  var name;\n\n  if (!Object.keys(model).length) return;\n\n  writer.startElement('attributes');\n  writer.writeAttribute('class', modelClass);\n\n  for (name in model) {\n    writer.startElement('attribute');\n    writer.writeAttribute('id', name);\n    writer.writeAttribute('title', name);\n    writer.writeAttribute('type', model[name]);\n    writer.endElement();\n  }\n\n  writer.endElement();\n}\n\nfunction writeElements(version, writer, type, model, elements) {\n  var emptyModel = !Object.keys(model).length;\n  var element;\n  var name;\n  var color;\n  var value;\n  var edgeType;\n  var attributes;\n  var weight;\n  var viz;\n  var k;\n  var i;\n  var l;\n\n  writer.startElement(type + 's');\n\n  for (i = 0, l = elements.length; i < l; i++) {\n    element = elements[i];\n    attributes = element.attributes;\n    viz = element.viz;\n\n    writer.startElement(type);\n    writer.writeAttribute('id', element.key);\n\n    if (type === 'edge') {\n      edgeType = element.undirected ? 'undirected' : 'directed';\n\n      if (edgeType !== writer.defaultEdgeType)\n        writer.writeAttribute('type', edgeType);\n\n      writer.writeAttribute('source', element.source);\n      writer.writeAttribute('target', element.target);\n\n      weight = element.weight;\n\n      if (\n        (typeof weight === 'number' && !isNaN(weight)) ||\n        typeof weight === 'string'\n      )\n        writer.writeAttribute('weight', element.weight);\n\n      if (element.kind) {\n        writer.writeAttribute('kind', element.kind);\n      }\n    }\n\n    if (element.label) writer.writeAttribute('label', element.label);\n\n    if (!emptyModel && attributes) {\n      writer.startElement('attvalues');\n\n      for (name in model) {\n        if (name in attributes) {\n          value = attributes[name];\n\n          if (isEmptyValue(value)) continue;\n\n          writer.startElement('attvalue');\n          writer.writeAttribute('for', name);\n          writer.writeAttribute('value', cast(version, model[name], value));\n          writer.endElement();\n        }\n      }\n\n      writer.endElement();\n    }\n\n    if (viz) {\n      //-- 1) Color\n      if (viz.color) {\n        writer.startElementNS('viz', 'color');\n\n        if (version === '1.3' && viz.color.startsWith('#')) {\n          writer.writeAttribute('hex', viz.color);\n        } else {\n          color = CSSColorToRGBA(viz.color);\n\n          for (k in color) writer.writeAttribute(k, color[k]);\n        }\n        writer.endElement();\n      }\n\n      //-- 2) Size\n      if (viz.size !== undefined) {\n        writer.startElementNS('viz', 'size');\n        writer.writeAttribute('value', viz.size);\n        writer.endElement();\n      }\n\n      //-- 3) Position\n      if (viz.x !== undefined || viz.y !== undefined || viz.z !== undefined) {\n        writer.startElementNS('viz', 'position');\n\n        if (viz.x !== undefined) writer.writeAttribute('x', viz.x);\n\n        if (viz.y !== undefined) writer.writeAttribute('y', viz.y);\n\n        if (viz.z !== undefined) writer.writeAttribute('z', viz.z);\n\n        writer.endElement();\n      }\n\n      //-- 4) Shape\n      if (viz.shape) {\n        writer.startElementNS('viz', 'shape');\n        writer.writeAttribute('value', viz.shape);\n        writer.endElement();\n      }\n\n      //-- 5) Thickness\n      if (viz.thickness !== undefined) {\n        writer.startElementNS('viz', 'thickness');\n        writer.writeAttribute('value', viz.thickness);\n        writer.endElement();\n      }\n    }\n\n    writer.endElement();\n  }\n\n  writer.endElement();\n}\n\n/**\n * Defaults.\n */\nvar DEFAULTS = {\n  encoding: 'UTF-8',\n  pretty: true,\n  version: '1.2',\n  pedantic: false,\n  formatNode: DEFAULT_NODE_FORMATTER,\n  formatEdge: DEFAULT_EDGE_FORMATTER\n};\n\n/**\n * Function taking a graphology instance & outputting a gexf string.\n *\n * @param  {Graph}  graph        - Target graphology instance.\n * @param  {object} options      - Options:\n * @param  {string}   [encoding]   - Character encoding.\n * @param  {boolean}  [pretty]     - Whether to pretty print output.\n * @param  {string}   [version]    - Gexf version to emit.\n * @param  {boolean}  [pedantic]   - Pedantic output?\n * @param  {function} [formatNode] - Function formatting nodes' output.\n * @param  {function} [formatEdge] - Function formatting edges' output.\n * @return {string}              - GEXF string.\n */\nmodule.exports = function write(graph, options) {\n  if (!isGraph(graph))\n    throw new Error('graphology-gexf/writer: invalid graphology instance.');\n\n  options = options || {};\n\n  var indent = options.pretty === false ? false : '  ';\n  var pedantic = options.pedantic === true;\n\n  var formatNode = options.formatNode || DEFAULTS.formatNode;\n  var formatEdge = options.formatEdge || DEFAULTS.formatEdge;\n\n  var writer = new XMLWriter(indent);\n\n  writer.startDocument('1.0', options.encoding || DEFAULTS.encoding);\n\n  // Starting gexf\n  var version = options.version || DEFAULTS.version;\n\n  if (version !== '1.2' && version !== '1.3') {\n    throw new Error(\n      'graphology-gexf/writer: invalid gexf version \"' +\n        version +\n        '\". Expecting 1.2 or 1.3.'\n    );\n  }\n\n  writer.startElement('gexf');\n  writer.writeAttribute('version', version);\n\n  if (version === '1.2') {\n    writer.writeAttribute('xmlns', 'http://www.gexf.net/1.2draft');\n    writer.writeAttribute('xmlns:viz', 'http:///www.gexf.net/1.1draft/viz');\n  } else if (version === '1.3') {\n    writer.writeAttribute('xmlns', 'http://gexf.net/1.3');\n    writer.writeAttribute('xmlns:viz', 'http://gexf.net/1.3/viz');\n    writer.writeAttribute(\n      'xmlns:xsi',\n      'http://www.w3.org/2001/XMLSchema-instance'\n    );\n    writer.writeAttribute(\n      'xsi:schemaLocation',\n      'http://gexf.net/1.3 http://gexf.net/1.3/gexf.xsd'\n    );\n  }\n\n  // Processing meta\n  writer.startElement('meta');\n  var graphAttributes = graph.getAttributes();\n\n  if (graphAttributes.lastModifiedDate)\n    writer.writeAttribute('lastmodifieddate', graphAttributes.lastModifiedDate);\n\n  var metaTagName;\n  var graphAttribute;\n\n  for (var k in graphAttributes) {\n    if (k === 'lastModifiedDate') continue;\n\n    if (pedantic && k !== 'creator' && k !== 'description' && k !== 'keywords')\n      continue;\n\n    metaTagName = sanitizeTagName(k);\n\n    if (!metaTagName) continue;\n\n    graphAttribute = graphAttributes[k];\n\n    // NOTE: if the graph attribute is not a scalar, we do not bother writing\n    // it as metadata in the gexf output. This means the writer/parser is not\n    // idempotent, but we cannot do better because the gexf format does not\n    // allow it, since it was not meant to handle complex values as graph\n    // metadata anyway.\n    if (\n      typeof graphAttribute === 'string' ||\n      typeof graphAttribute === 'number' ||\n      typeof graphAttribute === 'boolean'\n    ) {\n      writer.writeElement(metaTagName, '' + graphAttribute);\n    }\n  }\n\n  writer.endElement();\n  writer.startElement('graph');\n\n  var type = inferType(graph);\n\n  writer.defaultEdgeType = type === 'mixed' ? 'directed' : type;\n\n  writer.writeAttribute('defaultedgetype', writer.defaultEdgeType);\n\n  // Processing model\n  var nodes = collectNodeData(graph, formatNode);\n  var edges = collectEdgeData(graph, formatEdge);\n\n  var nodeModel = inferModel(nodes);\n\n  writeModel(writer, nodeModel, 'node');\n\n  var edgeModel = inferModel(edges);\n\n  writeModel(writer, edgeModel, 'edge');\n\n  // Processing nodes\n  writeElements(version, writer, 'node', nodeModel, nodes);\n\n  // Processing edges\n  writeElements(version, writer, 'edge', edgeModel, edges);\n\n  return writer.toString();\n};\n", "/**\n * Graphology Browser GEXF Endpoint\n * =================================\n *\n * Endpoint gathering both parser & writer for the browser.\n */\nexports.parse = require('./parser.js');\nexports.write = require('../common/writer.js');\n"],
  "mappings": "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",
  "names": ["DOMParser", "Document", "require_parser", "require_xml_writer"]
}
