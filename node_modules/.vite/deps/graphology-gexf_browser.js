import {
  require_is_graph
} from "./chunk-ULR5OFWV.js";
import {
  __commonJS
} from "./chunk-5WRI5ZAA.js";

// node_modules/graphology-utils/is-graph-constructor.js
var require_is_graph_constructor = __commonJS({
  "node_modules/graphology-utils/is-graph-constructor.js"(exports, module) {
    module.exports = function isGraphConstructor(value) {
      return value !== null && typeof value === "function" && typeof value.prototype === "object" && typeof value.prototype.addUndirectedEdgeWithKey === "function" && typeof value.prototype.dropNode === "function";
    };
  }
});

// node_modules/graphology-utils/add-edge.js
var require_add_edge = __commonJS({
  "node_modules/graphology-utils/add-edge.js"(exports) {
    exports.addEdge = function addEdge(graph, undirected, key, source, target, attributes) {
      if (undirected) {
        if (key === null || key === void 0)
          return graph.addUndirectedEdge(source, target, attributes);
        else return graph.addUndirectedEdgeWithKey(key, source, target, attributes);
      } else {
        if (key === null || key === void 0)
          return graph.addDirectedEdge(source, target, attributes);
        else return graph.addDirectedEdgeWithKey(key, source, target, attributes);
      }
    };
    exports.copyEdge = function copyEdge(graph, undirected, key, source, target, attributes) {
      attributes = Object.assign({}, attributes);
      if (undirected) {
        if (key === null || key === void 0)
          return graph.addUndirectedEdge(source, target, attributes);
        else return graph.addUndirectedEdgeWithKey(key, source, target, attributes);
      } else {
        if (key === null || key === void 0)
          return graph.addDirectedEdge(source, target, attributes);
        else return graph.addDirectedEdgeWithKey(key, source, target, attributes);
      }
    };
    exports.mergeEdge = function mergeEdge(graph, undirected, key, source, target, attributes) {
      if (undirected) {
        if (key === null || key === void 0)
          return graph.mergeUndirectedEdge(source, target, attributes);
        else
          return graph.mergeUndirectedEdgeWithKey(key, source, target, attributes);
      } else {
        if (key === null || key === void 0)
          return graph.mergeDirectedEdge(source, target, attributes);
        else return graph.mergeDirectedEdgeWithKey(key, source, target, attributes);
      }
    };
    exports.updateEdge = function updateEdge(graph, undirected, key, source, target, updater) {
      if (undirected) {
        if (key === null || key === void 0)
          return graph.updateUndirectedEdge(source, target, updater);
        else return graph.updateUndirectedEdgeWithKey(key, source, target, updater);
      } else {
        if (key === null || key === void 0)
          return graph.updateDirectedEdge(source, target, updater);
        else return graph.updateDirectedEdgeWithKey(key, source, target, updater);
      }
    };
  }
});

// node_modules/graphology-gexf/common/helpers.js
var require_helpers = __commonJS({
  "node_modules/graphology-gexf/common/helpers.js"(exports) {
    var SPACE_PATTERN = /^\s$/;
    var COMMA_SPLITTER = /\s*,\s*/;
    var PIPE_SPLITTER = /\s*\|\s*/;
    function isSpace(char) {
      return SPACE_PATTERN.test(char);
    }
    function parseListPieces(string) {
      var c, n, i, l;
      var inPiece = false;
      var escaping = false;
      var piece = void 0;
      var pieces = [];
      var quoting = "";
      for (i = 0, l = string.length; i < l; i++) {
        c = string[i];
        if (inPiece) {
          if (piece === void 0) {
            piece = "";
          }
          if (!quoting && c === ",") {
            i--;
            inPiece = false;
            continue;
          }
          if (!escaping && c === quoting) {
            inPiece = false;
            continue;
          }
          if (c === "\\") {
            if (i + 1 < l) {
              n = string[i + 1];
              if (n === "r" || n === "t" || n === "n" || n === "\\") {
                if (n === "n") {
                  piece += "\n";
                } else if (n === "t") {
                  piece += "	";
                } else if (n === "r") {
                  piece += "\r";
                } else {
                  piece += "\\";
                }
                escaping = false;
                i++;
                continue;
              }
            }
            escaping = true;
          } else {
            piece += c;
            escaping = false;
          }
        } else {
          if (isSpace(c)) {
            continue;
          }
          if (c === ",") {
            if (piece !== void 0) {
              pieces.push(piece);
              piece = void 0;
            }
            continue;
          }
          if (c === '"' || c === "'") {
            quoting = c;
          } else {
            i--;
            quoting = "";
          }
          inPiece = true;
          escaping = false;
        }
      }
      if (piece !== void 0) {
        pieces.push(piece);
      }
      return pieces;
    }
    function parseScalarValue(type, string) {
      if (!type || type === "string") {
        return string;
      }
      if (type === "boolean") {
        return string === "true";
      }
      if (type === "byte" || type === "short" || type === "integer" || type === "long" || type === "float" || type === "double") {
        return +string;
      }
      return string;
    }
    function parseValue(type, string) {
      if (type.startsWith("list")) {
        var subtype = type.slice(4);
        var pieces;
        if (string.length >= 2 && string[0] === "[" && string[string.length - 1] === "]") {
          pieces = parseListPieces(string.slice(1, -1));
        } else if (string.includes("|")) {
          pieces = string.split(PIPE_SPLITTER);
        } else if (string.includes(",")) {
          pieces = string.split(COMMA_SPLITTER);
        } else {
          pieces = [string];
        }
        return pieces.map(function(piece) {
          return parseScalarValue(subtype, piece);
        });
      } else {
        return parseScalarValue(type, string);
      }
    }
    exports.parseListPieces = parseListPieces;
    exports.parseScalarValue = parseScalarValue;
    exports.parseValue = parseValue;
    var SANITIZE_PATTERN = /["'<>&\s]/g;
    exports.sanitizeTagName = function sanitizeTagName(tagName) {
      return tagName.replace(SANITIZE_PATTERN, "").trim();
    };
  }
});

// node_modules/graphology-gexf/common/parser.js
var require_parser = __commonJS({
  "node_modules/graphology-gexf/common/parser.js"(exports, module) {
    var isGraphConstructor = require_is_graph_constructor();
    var mergeEdge = require_add_edge().mergeEdge;
    var helpers = require_helpers();
    var parseValue = helpers.parseValue;
    function isReallyNaN(value) {
      return value !== value;
    }
    function getVizColor(element) {
      var hex = element.getAttribute("hex");
      if (hex) {
        return hex;
      }
      var a = element.getAttribute("a");
      var r = element.getAttribute("r");
      var g = element.getAttribute("g");
      var b = element.getAttribute("b");
      return a ? "rgba(" + r + "," + g + "," + b + "," + a + ")" : "rgb(" + r + "," + g + "," + b + ")";
    }
    function getFirstMatchingVizTag(element, name) {
      var vizElement = element.getElementsByTagName("viz:" + name)[0];
      if (!vizElement) vizElement = element.getElementsByTagNameNS("viz", name)[0];
      if (!vizElement) vizElement = element.getElementsByTagName(name)[0];
      return vizElement;
    }
    function collectMeta(elements) {
      var meta = {};
      var element;
      var value;
      for (var i = 0, l = elements.length; i < l; i++) {
        element = elements[i];
        if (element.nodeName === "#text") continue;
        value = element.textContent.trim();
        if (value) meta[element.tagName.toLowerCase()] = element.textContent;
      }
      return meta;
    }
    function extractModel(elements) {
      var model = {};
      var defaults = {};
      var element;
      var defaultElement;
      var id;
      for (var i = 0, l = elements.length; i < l; i++) {
        element = elements[i];
        id = element.getAttribute("id") || element.getAttribute("for");
        model[id] = {
          id,
          type: element.getAttribute("type") || "string",
          title: !isReallyNaN(+id) ? element.getAttribute("title") || id : id
        };
        defaultElement = element.getElementsByTagName("default")[0];
        if (defaultElement)
          defaults[model[id].title] = parseValue(
            model[id].type,
            defaultElement.textContent
          );
      }
      return [model, defaults];
    }
    function collectAttributes(model, defaults, element, allowUndeclaredAttributes) {
      var data = {};
      var label = element.getAttribute("label");
      var weight = element.getAttribute("weight");
      var kind = element.getAttribute("kind");
      if (label) data.label = label;
      if (weight) data.weight = +weight;
      if (kind) data.kind = kind;
      var valueElements = element.getElementsByTagName("attvalue");
      var valueElement;
      var attr;
      var title;
      var value;
      var type;
      var id;
      for (var i = 0, l = valueElements.length; i < l; i++) {
        valueElement = valueElements[i];
        id = valueElement.getAttribute("id") || valueElement.getAttribute("for");
        value = valueElement.getAttribute("value");
        attr = model[id];
        if (!attr) {
          if (allowUndeclaredAttributes) {
            title = id;
            type = "string";
          } else {
            throw new Error(
              'graphology-gexf/parser: Found undeclared attribute "' + id + '"'
            );
          }
        } else {
          title = attr.title;
          type = attr.type;
        }
        data[title] = parseValue(type, value);
      }
      var k;
      for (k in defaults) {
        if (!(k in data)) data[k] = defaults[k];
      }
      var vizElement = getFirstMatchingVizTag(element, "color");
      if (vizElement) data.color = getVizColor(vizElement);
      vizElement = getFirstMatchingVizTag(element, "size");
      if (vizElement) data.size = +vizElement.getAttribute("value");
      var x, y, z;
      vizElement = getFirstMatchingVizTag(element, "position");
      if (vizElement) {
        x = vizElement.getAttribute("x");
        y = vizElement.getAttribute("y");
        z = vizElement.getAttribute("z");
        if (x) data.x = +x;
        if (y) data.y = +y;
        if (z) data.z = +z;
      }
      vizElement = getFirstMatchingVizTag(element, "shape");
      if (vizElement) data.shape = vizElement.getAttribute("value");
      vizElement = getFirstMatchingVizTag(element, "thickness");
      if (vizElement) data.thickness = +vizElement.getAttribute("value");
      return data;
    }
    module.exports = function createParserFunction(DOMParser2, Document2) {
      return function parse(Graph, source, options) {
        options = options || {};
        var addMissingNodes = options.addMissingNodes === true;
        var allowUndeclaredAttributes = options.allowUndeclaredAttributes === true;
        var respectInputGraphType = options.respectInputGraphType === true;
        var mergeResult;
        var xmlDoc = source;
        var element, result, type, attributes, id, s, t, i, l;
        if (!isGraphConstructor(Graph))
          throw new Error("graphology-gexf/parser: invalid Graph constructor.");
        if (typeof source === "string")
          xmlDoc = new DOMParser2().parseFromString(source, "application/xml");
        if (!(xmlDoc instanceof Document2))
          throw new Error(
            "graphology-gexf/parser: source should either be a XML document or a string."
          );
        var GRAPH_ELEMENT = xmlDoc.getElementsByTagName("graph")[0];
        var META_ELEMENT = xmlDoc.getElementsByTagName("meta")[0];
        var META_ELEMENTS = META_ELEMENT && META_ELEMENT.childNodes || [];
        var NODE_ELEMENTS = xmlDoc.getElementsByTagName("node");
        var EDGE_ELEMENTS = xmlDoc.getElementsByTagName("edge");
        var MODEL_ELEMENTS = xmlDoc.getElementsByTagName("attributes");
        var NODE_MODEL_ELEMENTS = [];
        var EDGE_MODEL_ELEMENTS = [];
        for (i = 0, l = MODEL_ELEMENTS.length; i < l; i++) {
          element = MODEL_ELEMENTS[i];
          if (element.getAttribute("class") === "node")
            NODE_MODEL_ELEMENTS = element.getElementsByTagName("attribute");
          else if (element.getAttribute("class") === "edge")
            EDGE_MODEL_ELEMENTS = element.getElementsByTagName("attribute");
        }
        var DEFAULT_EDGE_TYPE = GRAPH_ELEMENT.getAttribute("defaultedgetype") || "undirected";
        if (DEFAULT_EDGE_TYPE === "mutual") DEFAULT_EDGE_TYPE = "undirected";
        result = extractModel(NODE_MODEL_ELEMENTS);
        var NODE_MODEL = result[0];
        var NODE_DEFAULT_ATTRIBUTES = result[1];
        result = extractModel(EDGE_MODEL_ELEMENTS);
        var EDGE_MODEL = result[0];
        var EDGE_DEFAULT_ATTRIBUTES = result[1];
        var graphType = EDGE_ELEMENTS[0] ? EDGE_ELEMENTS[0].getAttribute("type") || DEFAULT_EDGE_TYPE : "mixed";
        var graphOptions = respectInputGraphType ? {} : { type: graphType };
        var graph = new Graph(graphOptions);
        var meta = collectMeta(META_ELEMENTS);
        var lastModifiedDate = META_ELEMENT && META_ELEMENT.getAttribute("lastmodifieddate");
        graph.replaceAttributes(meta);
        if (lastModifiedDate)
          graph.setAttribute("lastModifiedDate", lastModifiedDate);
        for (i = 0, l = NODE_ELEMENTS.length; i < l; i++) {
          element = NODE_ELEMENTS[i];
          graph.addNode(
            element.getAttribute("id"),
            collectAttributes(
              NODE_MODEL,
              NODE_DEFAULT_ATTRIBUTES,
              element,
              allowUndeclaredAttributes
            )
          );
        }
        for (i = 0, l = EDGE_ELEMENTS.length; i < l; i++) {
          element = EDGE_ELEMENTS[i];
          id = element.getAttribute("id");
          type = element.getAttribute("type") || DEFAULT_EDGE_TYPE;
          s = element.getAttribute("source");
          t = element.getAttribute("target");
          attributes = collectAttributes(
            EDGE_MODEL,
            EDGE_DEFAULT_ATTRIBUTES,
            element,
            allowUndeclaredAttributes
          );
          if (type !== graph.type && graph.type !== "mixed") {
            if (respectInputGraphType)
              throw new Error(
                "graphology-gexf/parser: one of the file's edges does not respect the input graph type: " + graph.type + "."
              );
            graph = graph.copy({ type: "mixed" });
          }
          if (!graph.multi && (type === "directed" && graph.hasDirectedEdge(s, t) || graph.hasUndirectedEdge(s, t))) {
            if (respectInputGraphType)
              throw new Error(
                "graphology-gexf/parser: the file contains parallel edges that the input graph type does not allow."
              );
            graph = graph.copy({ multi: true });
          }
          mergeResult = mergeEdge(
            graph,
            type !== "directed",
            id || null,
            s,
            t,
            attributes
          );
          if (!addMissingNodes && (mergeResult[2] || mergeResult[3])) {
            throw new Error(
              "graphology-gexf/parser: one of your gexf file edges points to an inexisting node. Set the parser `addMissingNodes` option to `true` if you do not care."
            );
          }
        }
        return graph;
      };
    };
  }
});

// node_modules/graphology-gexf/browser/parser.js
var require_parser2 = __commonJS({
  "node_modules/graphology-gexf/browser/parser.js"(exports, module) {
    var createParserFunction = require_parser();
    module.exports = createParserFunction(DOMParser, Document);
  }
});

// node_modules/graphology-utils/infer-type.js
var require_infer_type = __commonJS({
  "node_modules/graphology-utils/infer-type.js"(exports, module) {
    var isGraph = require_is_graph();
    module.exports = function inferType(graph) {
      if (!isGraph(graph))
        throw new Error(
          "graphology-utils/infer-type: expecting a valid graphology instance."
        );
      var declaredType = graph.type;
      if (declaredType !== "mixed") return declaredType;
      if (graph.directedSize === 0 && graph.undirectedSize === 0 || graph.directedSize > 0 && graph.undirectedSize > 0)
        return "mixed";
      if (graph.directedSize > 0) return "directed";
      return "undirected";
    };
  }
});

// node_modules/xml-writer/lib/xml-writer.js
var require_xml_writer = __commonJS({
  "node_modules/xml-writer/lib/xml-writer.js"(exports, module) {
    function isFalse(s) {
      return typeof s !== "number" && !s;
    }
    function strval(s) {
      if (typeof s == "string") {
        return s;
      } else if (typeof s == "number") {
        return s + "";
      } else if (typeof s == "function") {
        return s();
      } else if (s instanceof XMLWriter) {
        return s.toString();
      } else throw Error("Bad Parameter");
    }
    function XMLWriter(indent, callback) {
      if (!(this instanceof XMLWriter)) {
        return new XMLWriter();
      }
      this.name_regex = /[_:A-Za-z][-._:A-Za-z0-9]*/;
      this.indent = indent ? true : false;
      this.indentString = this.indent && typeof indent === "string" ? indent : "    ";
      this.output = "";
      this.stack = [];
      this.tags = 0;
      this.attributes = 0;
      this.attribute = 0;
      this.texts = 0;
      this.comment = 0;
      this.dtd = 0;
      this.root = "";
      this.pi = 0;
      this.cdata = 0;
      this.started_write = false;
      this.writer;
      this.writer_encoding = "UTF-8";
      if (typeof callback == "function") {
        this.writer = callback;
      } else {
        this.writer = function(s, e) {
          this.output += s;
        };
      }
    }
    XMLWriter.prototype = {
      toString: function() {
        this.flush();
        return this.output;
      },
      indenter: function() {
        if (this.indent) {
          this.write("\n");
          for (var i = 1; i < this.tags; i++) {
            this.write(this.indentString);
          }
        }
      },
      write: function() {
        for (var i = 0; i < arguments.length; i++) {
          this.writer(arguments[i], this.writer_encoding);
        }
      },
      flush: function() {
        for (var i = this.tags; i > 0; i--) {
          this.endElement();
        }
        this.tags = 0;
      },
      startDocument: function(version, encoding, standalone) {
        if (this.tags || this.attributes) return this;
        this.startPI("xml");
        this.startAttribute("version");
        this.text(typeof version == "string" ? version : "1.0");
        this.endAttribute();
        if (typeof encoding == "string") {
          this.startAttribute("encoding");
          this.text(encoding);
          this.endAttribute();
          this.writer_encoding = encoding;
        }
        if (standalone) {
          this.startAttribute("standalone");
          this.text("yes");
          this.endAttribute();
        }
        this.endPI();
        if (!this.indent) {
          this.write("\n");
        }
        return this;
      },
      endDocument: function() {
        if (this.attributes) this.endAttributes();
        return this;
      },
      writeElement: function(name, content) {
        return this.startElement(name).text(content).endElement();
      },
      writeElementNS: function(prefix, name, uri, content) {
        if (!content) {
          content = uri;
        }
        return this.startElementNS(prefix, name, uri).text(content).endElement();
      },
      startElement: function(name) {
        name = strval(name);
        if (!name.match(this.name_regex)) throw Error("Invalid Parameter");
        if (this.tags === 0 && this.root && this.root !== name) throw Error("Invalid Parameter");
        if (this.attributes) this.endAttributes();
        ++this.tags;
        this.texts = 0;
        if (this.stack.length > 0)
          this.stack[this.stack.length - 1].containsTag = true;
        this.stack.push({
          name,
          tags: this.tags
        });
        if (this.started_write) this.indenter();
        this.write("<", name);
        this.startAttributes();
        this.started_write = true;
        return this;
      },
      startElementNS: function(prefix, name, uri) {
        prefix = strval(prefix);
        name = strval(name);
        if (!prefix.match(this.name_regex)) throw Error("Invalid Parameter");
        if (!name.match(this.name_regex)) throw Error("Invalid Parameter");
        if (this.attributes) this.endAttributes();
        ++this.tags;
        this.texts = 0;
        if (this.stack.length > 0)
          this.stack[this.stack.length - 1].containsTag = true;
        this.stack.push({
          name: prefix + ":" + name,
          tags: this.tags
        });
        if (this.started_write) this.indenter();
        this.write("<", prefix + ":" + name);
        this.startAttributes();
        this.started_write = true;
        return this;
      },
      endElement: function() {
        if (!this.tags) return this;
        var t = this.stack.pop();
        if (this.attributes > 0) {
          if (this.attribute) {
            if (this.texts) this.endAttribute();
            this.endAttribute();
          }
          this.write("/");
          this.endAttributes();
        } else {
          if (t.containsTag) this.indenter();
          this.write("</", t.name, ">");
        }
        --this.tags;
        this.texts = 0;
        return this;
      },
      writeAttribute: function(name, content) {
        if (typeof content == "function") {
          content = content();
        }
        if (isFalse(content)) {
          return this;
        }
        return this.startAttribute(name).text(content).endAttribute();
      },
      writeAttributeNS: function(prefix, name, uri, content) {
        if (!content) {
          content = uri;
        }
        if (typeof content == "function") {
          content = content();
        }
        if (isFalse(content)) {
          return this;
        }
        return this.startAttributeNS(prefix, name, uri).text(content).endAttribute();
      },
      startAttributes: function() {
        this.attributes = 1;
        return this;
      },
      endAttributes: function() {
        if (!this.attributes) return this;
        if (this.attribute) this.endAttribute();
        this.attributes = 0;
        this.attribute = 0;
        this.texts = 0;
        this.write(">");
        return this;
      },
      startAttribute: function(name) {
        name = strval(name);
        if (!name.match(this.name_regex)) throw Error("Invalid Parameter");
        if (!this.attributes && !this.pi) return this;
        if (this.attribute) return this;
        this.attribute = 1;
        this.write(" ", name, '="');
        return this;
      },
      startAttributeNS: function(prefix, name, uri) {
        prefix = strval(prefix);
        name = strval(name);
        if (!prefix.match(this.name_regex)) throw Error("Invalid Parameter");
        if (!name.match(this.name_regex)) throw Error("Invalid Parameter");
        if (!this.attributes && !this.pi) return this;
        if (this.attribute) return this;
        this.attribute = 1;
        this.write(" ", prefix + ":" + name, '="');
        return this;
      },
      endAttribute: function() {
        if (!this.attribute) return this;
        this.attribute = 0;
        this.texts = 0;
        this.write('"');
        return this;
      },
      text: function(content) {
        content = strval(content);
        if (!this.tags && !this.comment && !this.pi && !this.cdata) return this;
        if (this.attributes && this.attribute) {
          ++this.texts;
          this.write(
            content.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;")
          );
          return this;
        } else if (this.attributes && !this.attribute) {
          this.endAttributes();
        }
        if (this.comment || this.cdata) {
          this.write(content);
        } else {
          this.write(content.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"));
        }
        ++this.texts;
        this.started_write = true;
        return this;
      },
      writeComment: function(content) {
        return this.startComment().text(content).endComment();
      },
      startComment: function() {
        if (this.comment) return this;
        if (this.attributes) this.endAttributes();
        this.indenter();
        this.write("<!--");
        this.comment = 1;
        this.started_write = true;
        return this;
      },
      endComment: function() {
        if (!this.comment) return this;
        this.write("-->");
        this.comment = 0;
        return this;
      },
      writeDocType: function(name, pubid, sysid, subset) {
        return this.startDocType(name, pubid, sysid, subset).endDocType();
      },
      startDocType: function(name, pubid, sysid, subset) {
        if (this.dtd || this.tags) return this;
        name = strval(name);
        pubid = pubid ? strval(pubid) : pubid;
        sysid = sysid ? strval(sysid) : sysid;
        subset = subset ? strval(subset) : subset;
        if (!name.match(this.name_regex)) throw Error("Invalid Parameter");
        if (pubid && !pubid.match(/^[\w\-][\w\s\-\/\+\:\.]*/)) throw Error("Invalid Parameter");
        if (sysid && !sysid.match(/^[\w\.][\w\-\/\\\:\.]*/)) throw Error("Invalid Parameter");
        if (subset && !subset.match(/[\w\s\<\>\+\.\!\#\-\?\*\,\(\)\|]*/)) throw Error("Invalid Parameter");
        pubid = pubid ? ' PUBLIC "' + pubid + '"' : sysid ? " SYSTEM" : "";
        sysid = sysid ? ' "' + sysid + '"' : "";
        subset = subset ? " [" + subset + "]" : "";
        if (this.started_write) this.indenter();
        this.write("<!DOCTYPE ", name, pubid, sysid, subset);
        this.root = name;
        this.dtd = 1;
        this.started_write = true;
        return this;
      },
      endDocType: function() {
        if (!this.dtd) return this;
        this.write(">");
        return this;
      },
      writePI: function(name, content) {
        return this.startPI(name).text(content).endPI();
      },
      startPI: function(name) {
        name = strval(name);
        if (!name.match(this.name_regex)) throw Error("Invalid Parameter");
        if (this.pi) return this;
        if (this.attributes) this.endAttributes();
        if (this.started_write) this.indenter();
        this.write("<?", name);
        this.pi = 1;
        this.started_write = true;
        return this;
      },
      endPI: function() {
        if (!this.pi) return this;
        this.write("?>");
        this.pi = 0;
        return this;
      },
      writeCData: function(content) {
        return this.startCData().text(content).endCData();
      },
      startCData: function() {
        if (this.cdata) return this;
        if (this.attributes) this.endAttributes();
        this.indenter();
        this.write("<![CDATA[");
        this.cdata = 1;
        this.started_write = true;
        return this;
      },
      endCData: function() {
        if (!this.cdata) return this;
        this.write("]]>");
        this.cdata = 0;
        return this;
      },
      writeRaw: function(content) {
        content = strval(content);
        if (!this.tags && !this.comment && !this.pi && !this.cdata) return this;
        if (this.attributes && this.attribute) {
          ++this.texts;
          this.write(content.replace("&", "&amp;").replace('"', "&quot;"));
          return this;
        } else if (this.attributes && !this.attribute) {
          this.endAttributes();
        }
        ++this.texts;
        this.write(content);
        this.started_write = true;
        return this;
      }
    };
    module.exports = XMLWriter;
  }
});

// node_modules/xml-writer/index.js
var require_xml_writer2 = __commonJS({
  "node_modules/xml-writer/index.js"(exports, module) {
    module.exports = require_xml_writer();
  }
});

// node_modules/graphology-gexf/common/writer.js
var require_writer = __commonJS({
  "node_modules/graphology-gexf/common/writer.js"(exports, module) {
    var isGraph = require_is_graph();
    var inferType = require_infer_type();
    var XMLWriter = require_xml_writer2();
    var sanitizeTagName = require_helpers().sanitizeTagName;
    var VIZ_RESERVED_NAMES = /* @__PURE__ */ new Set([
      "color",
      "size",
      "x",
      "y",
      "z",
      "shape",
      "thickness"
    ]);
    var RGBA_TEST = /^\s*rgba?\s*\(/i;
    var RGBA_MATCH = /^\s*rgba?\s*\(\s*([0-9]*)\s*,\s*([0-9]*)\s*,\s*([0-9]*)\s*(?:,\s*([.0-9]*))?\)\s*$/;
    function CSSColorToRGBA(value) {
      if (!value || typeof value !== "string") return {};
      if (value[0] === "#") {
        value = value.slice(1);
        return value.length === 3 ? {
          r: parseInt(value[0] + value[0], 16),
          g: parseInt(value[1] + value[1], 16),
          b: parseInt(value[2] + value[2], 16)
        } : {
          r: parseInt(value[0] + value[1], 16),
          g: parseInt(value[2] + value[3], 16),
          b: parseInt(value[4] + value[5], 16)
        };
      } else if (RGBA_TEST.test(value)) {
        var result = {};
        value = value.match(RGBA_MATCH);
        result.r = +value[1];
        result.g = +value[2];
        result.b = +value[3];
        if (value[4]) result.a = +value[4];
        return result;
      }
      return {};
    }
    function DEFAULT_ELEMENT_FORMATTER(type, key, attributes) {
      var output = {}, name;
      for (name in attributes) {
        if (name === "label") {
          output.label = attributes.label;
        } else if (type === "edge" && name === "weight") {
          output.weight = attributes.weight;
        } else if (type === "edge" && name === "kind") {
          output.kind = attributes.kind;
        } else if (VIZ_RESERVED_NAMES.has(name)) {
          output.viz = output.viz || {};
          output.viz[name] = attributes[name];
        } else {
          output.attributes = output.attributes || {};
          output.attributes[name] = attributes[name];
        }
      }
      return output;
    }
    var DEFAULT_NODE_FORMATTER = DEFAULT_ELEMENT_FORMATTER.bind(null, "node");
    var DEFAULT_EDGE_FORMATTER = DEFAULT_ELEMENT_FORMATTER.bind(null, "edge");
    function is32BitInteger(number) {
      return number <= 2147483647 && number >= -2147483647;
    }
    function isEmptyValue(value) {
      return typeof value === "undefined" || value === null || value === "" || value !== value;
    }
    var TYPE_PRIORITIES = {
      liststring: 0,
      listdouble: 1,
      listlong: 2,
      listinteger: 3,
      listboolean: 4,
      string: 5,
      double: 6,
      long: 7,
      integer: 8,
      boolean: 9,
      empty: 10
    };
    function inferScalarValueType(value) {
      if (isEmptyValue(value)) return "empty";
      if (typeof value === "boolean") return "boolean";
      if (typeof value === "object") return "string";
      if (typeof value === "number") {
        if (value === (value | 0)) {
          return is32BitInteger(value) ? "integer" : "long";
        }
        return "double";
      }
      return "string";
    }
    function inferListValueType(values) {
      var type = "empty";
      var priority = TYPE_PRIORITIES[type];
      var value, t, p;
      for (var i = 0, l = values.length; i < l; i++) {
        value = values[i];
        t = inferScalarValueType(value);
        p = TYPE_PRIORITIES[t];
        if (p < priority) {
          type = t;
          priority = p;
        }
      }
      return type;
    }
    function inferValueType(value) {
      if (value instanceof Set) {
        value = Array.from(value);
      }
      if (Array.isArray(value)) {
        var type = inferListValueType(value);
        if (type === "empty") return "empty";
        return "list" + type;
      }
      return inferScalarValueType(value);
    }
    var TO_SANITIZE_PATTERN = /[\r\t\n]/g;
    var SINGLE_QUOTE = "'";
    var DOUBLE_QUOTE = '"';
    function serializeValue(type, value) {
      if (type !== "string" || TO_SANITIZE_PATTERN.test(value)) {
        return JSON.stringify(value);
      }
      if (!value.includes(SINGLE_QUOTE)) {
        if (!value.includes(DOUBLE_QUOTE)) {
          return value;
        }
        return SINGLE_QUOTE + value + SINGLE_QUOTE;
      }
      return JSON.stringify(value);
    }
    function cast(version, type, value) {
      if (type.startsWith("list")) {
        if (value instanceof Set) value = Array.from(value);
        var arrayValue = Array.isArray(value) ? value : [value];
        var subtype = type.slice(4);
        if (version === "1.3") {
          return "[" + arrayValue.map(function(v) {
            return serializeValue(subtype, v);
          }).join(", ") + "]";
        } else {
          return arrayValue.join("|");
        }
      }
      return "" + value;
    }
    function collectNodeData(graph, format) {
      var nodes = new Array(graph.order);
      var i = 0;
      graph.forEachNode(function(node, attr) {
        var data = format(node, attr);
        data.key = node;
        nodes[i++] = data;
      });
      return nodes;
    }
    function collectEdgeData(graph, reducer) {
      var edges = new Array(graph.size);
      var i = 0;
      graph.forEachEdge(function(edge, attr, source, target, _sa, _ta, undirected) {
        var data = reducer(edge, attr);
        data.key = edge;
        data.source = source;
        data.target = target;
        data.undirected = undirected;
        edges[i++] = data;
      });
      return edges;
    }
    function inferModel(elements) {
      var model = {};
      var attributes;
      var type, currentType;
      var k;
      for (var i = 0, l = elements.length; i < l; i++) {
        attributes = elements[i].attributes;
        if (!attributes) continue;
        for (k in attributes) {
          type = inferValueType(attributes[k]);
          if (type === "empty") continue;
          currentType = model[k];
          if (!currentType) model[k] = type;
          else {
            if (type !== currentType && TYPE_PRIORITIES[type] < TYPE_PRIORITIES[currentType]) {
              model[k] = type;
            }
          }
        }
      }
      return model;
    }
    function writeModel(writer, model, modelClass) {
      var name;
      if (!Object.keys(model).length) return;
      writer.startElement("attributes");
      writer.writeAttribute("class", modelClass);
      for (name in model) {
        writer.startElement("attribute");
        writer.writeAttribute("id", name);
        writer.writeAttribute("title", name);
        writer.writeAttribute("type", model[name]);
        writer.endElement();
      }
      writer.endElement();
    }
    function writeElements(version, writer, type, model, elements) {
      var emptyModel = !Object.keys(model).length;
      var element;
      var name;
      var color;
      var value;
      var edgeType;
      var attributes;
      var weight;
      var viz;
      var k;
      var i;
      var l;
      writer.startElement(type + "s");
      for (i = 0, l = elements.length; i < l; i++) {
        element = elements[i];
        attributes = element.attributes;
        viz = element.viz;
        writer.startElement(type);
        writer.writeAttribute("id", element.key);
        if (type === "edge") {
          edgeType = element.undirected ? "undirected" : "directed";
          if (edgeType !== writer.defaultEdgeType)
            writer.writeAttribute("type", edgeType);
          writer.writeAttribute("source", element.source);
          writer.writeAttribute("target", element.target);
          weight = element.weight;
          if (typeof weight === "number" && !isNaN(weight) || typeof weight === "string")
            writer.writeAttribute("weight", element.weight);
          if (element.kind) {
            writer.writeAttribute("kind", element.kind);
          }
        }
        if (element.label) writer.writeAttribute("label", element.label);
        if (!emptyModel && attributes) {
          writer.startElement("attvalues");
          for (name in model) {
            if (name in attributes) {
              value = attributes[name];
              if (isEmptyValue(value)) continue;
              writer.startElement("attvalue");
              writer.writeAttribute("for", name);
              writer.writeAttribute("value", cast(version, model[name], value));
              writer.endElement();
            }
          }
          writer.endElement();
        }
        if (viz) {
          if (viz.color) {
            writer.startElementNS("viz", "color");
            if (version === "1.3" && viz.color.startsWith("#")) {
              writer.writeAttribute("hex", viz.color);
            } else {
              color = CSSColorToRGBA(viz.color);
              for (k in color) writer.writeAttribute(k, color[k]);
            }
            writer.endElement();
          }
          if (viz.size !== void 0) {
            writer.startElementNS("viz", "size");
            writer.writeAttribute("value", viz.size);
            writer.endElement();
          }
          if (viz.x !== void 0 || viz.y !== void 0 || viz.z !== void 0) {
            writer.startElementNS("viz", "position");
            if (viz.x !== void 0) writer.writeAttribute("x", viz.x);
            if (viz.y !== void 0) writer.writeAttribute("y", viz.y);
            if (viz.z !== void 0) writer.writeAttribute("z", viz.z);
            writer.endElement();
          }
          if (viz.shape) {
            writer.startElementNS("viz", "shape");
            writer.writeAttribute("value", viz.shape);
            writer.endElement();
          }
          if (viz.thickness !== void 0) {
            writer.startElementNS("viz", "thickness");
            writer.writeAttribute("value", viz.thickness);
            writer.endElement();
          }
        }
        writer.endElement();
      }
      writer.endElement();
    }
    var DEFAULTS = {
      encoding: "UTF-8",
      pretty: true,
      version: "1.2",
      pedantic: false,
      formatNode: DEFAULT_NODE_FORMATTER,
      formatEdge: DEFAULT_EDGE_FORMATTER
    };
    module.exports = function write(graph, options) {
      if (!isGraph(graph))
        throw new Error("graphology-gexf/writer: invalid graphology instance.");
      options = options || {};
      var indent = options.pretty === false ? false : "  ";
      var pedantic = options.pedantic === true;
      var formatNode = options.formatNode || DEFAULTS.formatNode;
      var formatEdge = options.formatEdge || DEFAULTS.formatEdge;
      var writer = new XMLWriter(indent);
      writer.startDocument("1.0", options.encoding || DEFAULTS.encoding);
      var version = options.version || DEFAULTS.version;
      if (version !== "1.2" && version !== "1.3") {
        throw new Error(
          'graphology-gexf/writer: invalid gexf version "' + version + '". Expecting 1.2 or 1.3.'
        );
      }
      writer.startElement("gexf");
      writer.writeAttribute("version", version);
      if (version === "1.2") {
        writer.writeAttribute("xmlns", "http://www.gexf.net/1.2draft");
        writer.writeAttribute("xmlns:viz", "http:///www.gexf.net/1.1draft/viz");
      } else if (version === "1.3") {
        writer.writeAttribute("xmlns", "http://gexf.net/1.3");
        writer.writeAttribute("xmlns:viz", "http://gexf.net/1.3/viz");
        writer.writeAttribute(
          "xmlns:xsi",
          "http://www.w3.org/2001/XMLSchema-instance"
        );
        writer.writeAttribute(
          "xsi:schemaLocation",
          "http://gexf.net/1.3 http://gexf.net/1.3/gexf.xsd"
        );
      }
      writer.startElement("meta");
      var graphAttributes = graph.getAttributes();
      if (graphAttributes.lastModifiedDate)
        writer.writeAttribute("lastmodifieddate", graphAttributes.lastModifiedDate);
      var metaTagName;
      var graphAttribute;
      for (var k in graphAttributes) {
        if (k === "lastModifiedDate") continue;
        if (pedantic && k !== "creator" && k !== "description" && k !== "keywords")
          continue;
        metaTagName = sanitizeTagName(k);
        if (!metaTagName) continue;
        graphAttribute = graphAttributes[k];
        if (typeof graphAttribute === "string" || typeof graphAttribute === "number" || typeof graphAttribute === "boolean") {
          writer.writeElement(metaTagName, "" + graphAttribute);
        }
      }
      writer.endElement();
      writer.startElement("graph");
      var type = inferType(graph);
      writer.defaultEdgeType = type === "mixed" ? "directed" : type;
      writer.writeAttribute("defaultedgetype", writer.defaultEdgeType);
      var nodes = collectNodeData(graph, formatNode);
      var edges = collectEdgeData(graph, formatEdge);
      var nodeModel = inferModel(nodes);
      writeModel(writer, nodeModel, "node");
      var edgeModel = inferModel(edges);
      writeModel(writer, edgeModel, "edge");
      writeElements(version, writer, "node", nodeModel, nodes);
      writeElements(version, writer, "edge", edgeModel, edges);
      return writer.toString();
    };
  }
});

// node_modules/graphology-gexf/browser/index.js
var require_browser = __commonJS({
  "node_modules/graphology-gexf/browser/index.js"(exports) {
    exports.parse = require_parser2();
    exports.write = require_writer();
  }
});
export default require_browser();
//# sourceMappingURL=graphology-gexf_browser.js.map
